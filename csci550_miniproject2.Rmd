```{r packages}
library(GGally)
library(janitor)
library(corrplot)

library(ggfortify) ## PCA Plots
library(glmnet) ## Penalized Regression
library(MASS) ## Step Selection
library(MuMIn) ## Compare Model Performance
library(caret)
library(splines)
library(tidyverse)

set.seed(123)
```

```{r load-data}
house_prices <- read_csv("./cook_county_train_val.csv")

house_prices <- house_prices %>% clean_names()

# Drop meaningless variables
house_prices <- house_prices %>% select(-x1, -pin, -description)

# These columns only have one level per factor, so are not useful for modeling
house_prices <- house_prices %>%
  select(-use, -modeling_group)

# These are duplicates or modifications of other columns
house_prices <- house_prices %>%
  select(-neigborhood_code_mapping, -town_code, -neighborhood_code)

# Documentation says other improvements is not clean enough to be useful
house_prices <- house_prices %>%
  select(-other_improvements)

# Clean sale prices = 1
house_prices <- house_prices %>%
  filter(sale_price > 1)

# Codebook specifies that houses with missing age are set to 10.  Since we can't tell houses with missing age vs houses with true age 10, we decided to drop data points with age == 10.
house_prices <- house_prices %>%
  filter(age != 10)

# land_square_feet and lot_size are the same so we drop one
house_prices <- house_prices %>%
  select(-land_square_feet)

# there are lots of different fields treating date differently, for example sale month of year, sale half year, etc.  To cut down on redundant predictors, we are keeping sale year and sale month of year, as these fields contain the most information
house_prices <- house_prices %>%
  select(-sale_quarter, -sale_half_year, -sale_quarter_of_year, -sale_half_of_year)

# deed number is a unique ID that appears randomly assigned
house_prices <- house_prices %>%
  select(-deed_no)

# age_decade is just age / 10
house_prices <- house_prices %>%
  select(-age_decade)

# lots of zeroes for estimate_land and estimate_building.  We are interested in how good of a predictor of sale prices these estimates are, so we are dropping observations where these are 0
house_prices <- house_prices %>%
  filter(estimate_land != 0, estimate_building != 0)


# apartments ranges from 0 to 6, but there are no observations with 1 apartment.  We want to treat this variable as continuous, so we are transforming apartments = 0 to 1.  This means that an observation with 1 apartment is a free standing dwelling, 2+ apartments is an apartment complex.
house_prices <- house_prices %>%
  mutate(apartments = if_else(apartments == 0, 1, apartments))


house_prices <- house_prices %>%
  mutate_at(vars(property_class,
                 wall_material,
                 roof_material,
                 basement,
                 basement_finish,
                 central_heating,
                 other_heating,
                 central_air,
                 attic_type,
                 attic_finish,
                 design_plan,
                 cathedral_ceiling,
                 construction_quality,
                 site_desirability,
                 garage_1_material,
                 garage_1_attachment,
                 garage_1_area,
                 garage_2_material,
                 garage_2_attachment,
                 garage_2_area,
                 porch,
                 repair_condition,
                 multi_code,
                 census_tract,
                 multi_property_indicator,
                 o_hare_noise,
                 floodplain,
                 road_proximity,
                 pure_market_filter,
                 garage_indicator,
                 town_and_neighborhood,
                 sale_month_of_year),
            factor)

input_matrix <- model.matrix(sale_price ~ -1 + ., data = house_prices)
```

```{r eda}
house_prices %>%
  select(-census_tract, -town_and_neighborhood) %>%
  ggpairs()


M <- cor(select_if(house_prices, is.numeric))
corrplot(M)

select_if(house_prices, is.numeric) %>%
  ggpairs()

select_if(house_prices, is.factor) %>%
  ggpairs()
```


``` r
house_prices %>%
  sample_n(5000) %>%
  vis_miss(warn_large_data = FALSE)

summary(house_prices) %>%
  knitr::kable()

# Levels per factor
sapply(house_prices[sapply(house_prices, is.factor)], nlevels)


baseline <- lm(sale_price ~ building_square_feet, data = house_prices)

summary(baseline)

null_model <- lm(sale_price ~ 1, data = house_prices)
full_model <- lm(sale_price ~ ., data = house_prices)

summary(full_model)
```

# Subset Selection
``` {r subset-selection}
step_fit <- stepAIC(null_model,  scope = list(lower = null_model, upper = full_model), direction = "forward")
```

# L_1/L_2 Regularized Regression

``` {r ridge-lasso}
lasso.cv <- cv.glmnet(x = input_matrix,
                      y = house_prices$sale_price,
                      alpha = 1,
                      nfolds = 5,
                      parallel = TRUE)

plot(lasso.cv)

coef(lasso.cv, s = "lambda.min")

ridge.cv <- cv.glmnet(x = input_matrix,
                      y = house_prices$sale_price,
                      alpha = 0,
                      nfolds = 5,
                      parallel = TRUE)

plot(ridge.cv)

coef(ridge.cv, s = "lambda.min")
```


# PCA

``` {r pca}
pca <- prcomp(input_matrix)

plot(pca)

autoplot(pca,
         data = house_prices,
         color = "property_class",
         loadings = TRUE,
         loadings.color = "blue",
         loadings.label = TRUE,
         loadings.label.size = 5)

components <- pca[["x"]]

components <- data.frame(components)

components$PC3 <- -components$PC3

components$PC2 <- -components$PC2
```

```{r non-linear}
ggplot(house_prices, aes(x = building_square_feet, y = sale_price)) +
  geom_point()

smooth <- smooth.spline(x = house_prices$building_square_feet, y = house_prices$sale_price, cv = F)
```
